<?xml version="1.0" encoding="UTF-8"?>
<section name="Workbench">
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog">
		<item value="false" key="isRegEx"/>
		<item value="compressionTable" key="selection"/>
		<item value="false" key="casesensitive"/>
		<item value="false" key="incremental"/>
		<item value="true" key="wrap"/>
		<item value="false" key="wholeword"/>
		<list key="findhistory">
			<item value="count"/>
			<item value="HuffmanNode"/>
			<item value="System"/>
			<item value="Encoding"/>
			<item value="HuffmanConverter"/>
			<item value="price"/>
			<item value="stock"/>
			<item value="setGOOGPrice"/>
		</list>
		<list key="replacehistory">
			<item value="compressionTable"/>
			<item value="HuffmanTreeNode"/>
			<item value="import java.io.*;&#x0A;import java.util.ArrayList;&#x0A;import java.util.StringTokenizer;&#x0A;&#x0A;/**&#x0A;* Stephen Blackmore&#x0A;* New York University&#x0A;* Homework 9&#x0A;* Prof. Korth&#x0A;* &#x0A;* This program takes a file name as an argument (in this case a poem) and simulates Huffman coding.&#x0A;* It outputs a count of each ASCII character, the Huffman encoding for each character,&#x0A;*  the huffman encoded input, and the decoded input.&#x0A;*  &#x0A;*  Supplemental class files:&#x0A;*  BinaryHeap.java&#x0A;*  HuffmanConverter.java&#x0A;*  HuffmanNode.java&#x0A;*/&#x0A;&#x0A;public class HuffmanTree &#x0A;{&#x0A;&#x0A;&#x09; HuffmanNode root;&#x0A;&#x09;  &#x0A;&#x09; public HuffmanTree(HuffmanNode huff)&#x0A;&#x09; {&#x0A;&#x09;&#x09; /* sets this.root to huff&#x0A;&#x09;&#x09;    * Before calling this constructor, we make a BinaryHeap of HuffmanNodes where each &#x0A;&#x09;&#x09;    * node has its left &amp; right pointers set appropriately via the constructor in 2. above. &#x0A;&#x09;&#x09;    * Once the final HuffmanNode (containing all the others) is removed from the heap, &#x0A;&#x09;&#x09;    * we make that into a HuffmanTree object by calling this constructor.&#x0A;&#x09;&#x09;   */ &#x0A;&#x09;&#x09; this.root = huff;&#x09; &#x0A;&#x09; &#x0A;&#x09; } // end HuffmanTree constructor&#x0A;&#x0A;&#x09; public void printLegend()&#x0A;&#x09; {&#x0A;&#x09;&#x09;// Calls private printLegend(root, &quot;&quot;)&#x0A;&#x09;&#x09; this.printLegend(root, &quot;&quot;); &#x0A;&#x09; } // end public printLegend&#x0A;&#x09; &#x0A;&#x09; private void printLegend(HuffmanNode t, String s)&#x0A;&#x09; {&#x0A;&#x09;&#x09; /*&#x0A;&#x09;&#x09;  * works as follows:&#x0A;&#x09;&#x09;  * If (t.letter.length() &gt; 1) i.e., t contains multiple characters, then t is NOT a leaf node, &#x0A;&#x09;&#x09;       so we recursively call printLegend() on it&apos;s left child using string s + &quot;0&quot;, and &#x0A;&#x09;&#x09;       recurse on t&apos;s right child using string s + &quot;1&quot;&#x0A;&#x09;&#x09;       &#x0A;&#x09;&#x09;  * If t.letter is a single character, then t is a leaf node, and we print out &#x0A;&#x09;&#x09;  * (t.letter+&quot;=&quot;+s);&#x0A;&#x09;&#x09;  */&#x0A;&#x09;&#x09; if(t.letter.length() &gt; 1)&#x0A;&#x09;&#x09; {&#x09; // go to left child&#x0A;&#x09;&#x09;&#x09; this.printLegend(t.left,s + &quot;0&quot;);&#x0A;&#x09;&#x09; &#x09; this.printLegend(t.right, s + &quot;1&quot;);&#x0A;&#x09;&#x09; }&#x0A;&#x09;&#x09; else&#x0A;&#x09;&#x09;&#x09; System.out.print(t.letter + &quot;=&quot; + s + &quot; &quot;);&#x0A;&#x09;&#x09; &#x0A;&#x09; } // end private printLegend&#x0A;&#x09;&#x0A;&#x09; // send to Binary Heap&#x0A;&#x09;@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot; })&#x0A;&#x09;public static BinaryHeap fileToHeap(String filename) throws IOException &#x0A;&#x09; {&#x0A;&#x09; /* Takes a String for the file name containing our input (letter &amp; frequency data). &#x0A;&#x09;  * The letters and frequencies are all in the first line of the file, with spaces as separators. &#x0A;&#x09;  * (You may assume each separator is a single space).&#x0A;&#x09;  */&#x0A;&#x09;&#x09; &#x09;File file = new File(filename);&#x0A;&#x09;&#x09; &#x09;Object[] inputStream = null;&#x0A;&#x09;&#x09; &#x09;String fileContent = null;&#x0A;&#x09;&#x09;&#x09; try {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;fileContent = &#x09;readFileAsString(filename);&#x0A;&#x09;&#x09;&#x09;} catch (IOException e) {&#x0A;&#x09;&#x09;&#x09;&#x09;// TODO Auto-generated catch block&#x0A;&#x09;&#x09;&#x09;&#x09;e.printStackTrace();&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09; ArrayList letterFrequency = new ArrayList();&#x0A;&#x09;&#x09;&#x09; StringTokenizer tokens = new StringTokenizer(fileContent);&#x0A;&#x09;&#x09;&#x09; while(tokens.hasMoreTokens())&#x0A;&#x09;&#x09;&#x09; {&#x0A;&#x09;&#x09;&#x09;&#x09; letterFrequency.add(tokens.nextElement());&#x09; &#x0A;&#x09;&#x09;&#x09; }&#x0A;&#x09;&#x09;&#x09; &#x0A;&#x09;&#x09;&#x09; Object[] letterFreqs = letterFrequency.toArray();&#x0A;&#x09;&#x09;&#x09; // since each letter must have a number associated, there will be half as many nodes as the length of the &#x0A;&#x09;&#x09;&#x09; // letterFreqs array&#x0A;&#x09;&#x09;&#x09; HuffmanNode[] letterNodes = new HuffmanNode[letterFreqs.length/2];&#x0A;&#x09;&#x09;&#x09; int id = 0;&#x0A;&#x09;&#x09;&#x09; int nodeIdx = 0;&#x0A;&#x09;&#x09;&#x09; while(id &lt; letterFreqs.length)&#x0A;&#x09;&#x09;&#x09; {&#x0A;&#x09;&#x09;&#x09;&#x09; String letter = (String) letterFreqs[id];&#x0A;&#x09;&#x09;&#x09;&#x09; String f = (String) letterFreqs[id+1];&#x0A;&#x09;&#x09;&#x09;&#x09; double freq = Double.parseDouble(f);&#x0A;&#x09;&#x09;&#x09;&#x09; HuffmanNode insert = new HuffmanNode(letter,freq);&#x0A;&#x09;&#x09;&#x09;&#x09; letterNodes[nodeIdx] = insert;&#x0A;&#x09;&#x09;&#x09;&#x09; id = id+2;&#x0A;&#x09;&#x09;&#x09;&#x09; nodeIdx++;&#x0A;&#x09;&#x09;&#x09; }&#x0A;&#x09;&#x09;&#x09; &#x0A;&#x09;&#x09;&#x09; BinaryHeap theHeap = new BinaryHeap (letterNodes);&#x0A;&#x09;&#x09; return theHeap;&#x0A;&#x09;&#x09; &#x0A;&#x09; } // end fileToHeap&#x0A;&#x09; &#x0A;&#x09; private static String readFileAsString(String filePath) throws java.io.IOException&#x0A;&#x09; {&#x0A;&#x09;&#x09;    byte[] buffer = new byte[(int) new File(filePath).length()];&#x0A;&#x09;&#x09;    FileInputStream f = new FileInputStream(filePath);&#x0A;&#x09;&#x09;    f.read(buffer);&#x0A;&#x09;&#x09; return new String(buffer);&#x0A;&#x09;&#x09;    &#x0A;&#x09; } // end readFileAsString&#x0A;&#x09; &#x0A;&#x0A;&#x09;  @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })&#x0A;&#x09;public static Object[] read(String input)&#x0A;&#x09;  {&#x0A;&#x09;&#x09;    ArrayList arrList = new ArrayList();&#x0A;&#x09;&#x09;    int i = 0;&#x0A;&#x09; &#x09;    while (i &lt;input.length() )&#x0A;&#x09;&#x09;    {&#x0A;&#x09;&#x09;      Character nextInput = input.charAt(i);&#x0A;&#x09;&#x09;      if (nextInput != null) //&amp;&amp; short circuits&#x0A;&#x09;&#x09;      {  &#x0A;&#x09;&#x09;        arrList.add(nextInput);&#x0A;&#x09;&#x09;      } &#x0A;&#x09;&#x09;      i++;&#x0A;&#x09;&#x09;    }  // end while loop&#x0A;&#x09;&#x09;    Object[] inputArr = arrList.toArray();&#x0A;&#x09;&#x09;    return inputArr;&#x0A;&#x09;  } // end read&#x0A;&#x09;&#x09; &#x0A;&#x09;@SuppressWarnings({ &quot;unchecked&quot;,&quot;rawtypes&quot; })&#x0A;&#x09;public static HuffmanTree createFromHeap(BinaryHeap b) &#x0A;&#x09; {&#x0A;&#x09; /* We run the Huffman algorithm here. When we have only one element left in the heap, &#x0A;&#x09;  * we remove it, and create a new HuffmanTree object with root set to our removed object... &#x0A;&#x09;  */&#x0A;&#x09;&#x09; HuffmanNode huffRoot = null;&#x0A;&#x09;&#x09; while(!b.isEmpty())&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09; // find smallest item and put into HuffmanNode and remove from heap&#x0A;&#x09;&#x09;&#x09; huffRoot = (HuffmanNode) b.deleteMin();&#x0A;&#x09;&#x09;&#x09;// find smallest item and put into HuffmanNode and remove from heap&#x09;&#x0A;&#x09;&#x09;&#x09; if(!b.isEmpty())&#x0A;&#x09;&#x09;&#x09; {&#x0A;&#x09;&#x09;&#x09;&#x09; HuffmanNode min2 = (HuffmanNode) b.deleteMin();&#x0A;&#x09;&#x09;&#x09;&#x09; HuffmanNode merged = new HuffmanNode(huffRoot,min2);&#x0A;&#x09;&#x09;&#x09;&#x09; merged.left = min2;&#x0A;&#x09;&#x09;&#x09;&#x09; merged.right = huffRoot;&#x0A;&#x09;&#x09;&#x09;&#x09; b.insert((HuffmanNode) merged);&#x0A;&#x09;&#x09;&#x09; } // end if&#x0A;&#x09;&#x09;&#x09; &#x0A;&#x09;&#x09; } // end while loop&#x0A;&#x09;&#x09; return new HuffmanTree(huffRoot);&#x0A;&#x09;&#x09; &#x0A;&#x09; }&#x09;// end createFromHeap &#x0A;&#x0A;&#x09;@SuppressWarnings({ &quot;rawtypes&quot;})&#x0A;&#x09;public static void main(String[] args)&#x0A;&#x09; {&#x0A;&#x09;&#x09; // Test program&#x0A;&#x09;&#x09; final String filename = args[0];&#x0A;&#x09;&#x09; BinaryHeap testHeap = null;&#x0A;&#x09;&#x09; try &#x0A;&#x09;&#x09; {&#x0A;&#x09;&#x09;&#x09; testHeap = fileToHeap(filename);&#x0A;&#x09;&#x09; } &#x0A;&#x09;&#x09; catch (IOException e1) &#x0A;&#x09;&#x09; {&#x0A;&#x09;&#x09;// TODO Auto-generated catch block&#x0A;&#x09;&#x09;e1.printStackTrace();&#x0A;&#x09;&#x09; }&#x0A;&#x0A;&#x09;&#x09; HuffmanTree hTree = createFromHeap(testHeap);&#x0A;&#x09;&#x09; hTree.printLegend();&#x0A;&#x0A;&#x09; } // end main&#x0A;} // end HuffmnTre class&#x0A;"/>
			<item value="Huffman"/>
			<item value="count"/>
			<item value="account"/>
			<item value="setviewerCount"/>
			<item value="setvidCount"/>
		</list>
	</section>
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog_dialogBounds">
		<item value="257" key="DIALOG_WIDTH"/>
		<item value="1|Segoe UI|9.0|0|WINDOWS|1|-12|0|0|0|400|0|0|0|1|0|0|0|0|Segoe UI" key="DIALOG_FONT_NAME"/>
		<item value="376" key="DIALOG_HEIGHT"/>
		<item value="363" key="DIALOG_X_ORIGIN"/>
		<item value="519" key="DIALOG_Y_ORIGIN"/>
	</section>
</section>
